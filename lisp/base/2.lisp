(defun f (x sum n)
  (if (= x n)
    (+ sum x)
    (f (+ x 1) (+ sum x) n)))
(defun skip (n xs)
  (if (= n 0)
    xs
    (skip (- n 1) (rest xs))))
(defun take (n xs)
  (if (= n 0)
    nil
    (cons (first xs)
          (take (- n 1) (rest xs)))))
(defun slice (m n xs)
  (take (+ n (- m) 1)
        (skip (- m 1) xs)))
(defun n-th (n xs)
  (first (skip (- n 1) xs)))
(defun change-element (a n xs)
  (join (take (- n 1) xs)
        (cons a (skip n xs))))
(defun swap (m n xs)
  (let ((a (n-th m xs))
        (b (n-th n xs)))
      (change-element
        b m (change-element a n xs))))
(defun rev2 (xs &optional acc)
  (if (null xs)
    acc
    (rev2 (rest xs)
          (cons (first xs) acc))))
(defun fib (a b n)
  (if (= n 0)
    nil
    (cons a (fib b (+ a b) (- n 1)))))
(defun f (x)
  (progn
    (setq i (+ i 1))
    (if (<= x 1)
      x
      (+ (f (- x 1)) (f (- x 2))))))
(defun count-call (x)
  (progn
    (setq i 0)
    (let ((var (f x)))
      (list x val i))))
(defun len< (xs ys)
  (if (and xs ys)
    (len< (rest xs) (rest ys))
    ys))
(defun len<= (xs ys)
  (if (and xs ys)
      (len<= (rest xs) (rest ys))
      (not xs)))
(defun fa (x &optional (i 2))
  (if (= (mod x i) 0)
    (if (= x i)
      (cons i nil)
      (cons i (fa (/ x i) i)))
    (fa x (+ i 1))))
(defun fb (x &optional (i 2))
  (cond ((< (sqrt x) i)
          (cons x nil))
        ((= (mod x i) 0)
          (cons i (fb (/ x i) i)))
        (t (fb x (+ i 1)))))
(defun fc (x)
  (if (= (mod x 2) 0)
    (if (= x 2)
        (cons 2 nil)
        (cons 2 (fc (/ x 2))))
    (fd x 3)))
(defun f (a b x n)
  (if (< n x)
    nil
    (let ((xs (fc (+ (expt a x) b))))
      (cons (if (null (rest xs))
                (first xs) xs)
            (f a b (+ x 1) n)))))
; (defun fib (x)
;   (cond ((= x 0) 0)
;         ((= x 1) 1)
;         (t (+ (fib (- x 1)) (fib (- x 2))))))
; (defun join-2 (xs ys)
;   (if (null xs)
;     ys
;     (cons (first xs)
;           (join-2 (rest xs) ys))))
; (defun fa (x &key add)
;   (+ x add))
; (defun fb (&key a b c d e f)
;   (list a b c d e f))
; (defun fc (&optional &key a b c d)
;   (list a b c d))
; (defun fd (&optional &key a b (c 8) d)
;   (list a b c d))
; (defun fb (x &key add then-multiply-by)
  ; (* (+ x add) then-multiply-by))
; (defun f (n)
;   (labels ((g (x)
;             (if (< n x)
;               nil
;               (cons x (g (+ x 1))))))
;               (g 1)))
; (defun g (x)
;   (labels ((g2 (z)
;             (if (= z 0)
;               nil
;               (cons z (g2 (- z 1))))))
;               (rev (g2 x))))
; (defun fa (x)

;   (list (labels ((g (z) (+ z 12)))
;           (g x))
;         (labels ((g (z) (* z 12)))
;           (g x))))
; (defun fb (x)
;   (if x
;     (labels ((g (z) (+ z 2)))
;       (g 4))
;     (labels ((g (z) (* z 2)))
;       (g 4))))
; (defun diff (xs ys &optional (n 1))
;   (let ((a (first xs)) (b (first ys)))
;     (if (null xs)
;       nil
;       (cons (if (equal a b)
;                 n (cons a b))
;             (diff
;               (rest xs) (rest ys) (+ n 1))
;               ))))
; (defun fa (n)
;   (g 1 n))

; (defun g (x n)
;   (if (< n x)
;     nil
;     (cons x (g (+ x 1) n))))
; (defun fc (&optional a b (c 10) d)
;   (list a b c d))
; (defun f (&optional (x a))
;   x)
; (defun fb (n &optional (x 1))
;   (if (< n x)
;     nil
;     (cons x (fb n (+ x 1)))))
; ; (defun g (&optional (x (+ 2 3))) x)
; ; (defun fa (x &optional y)
; ;   (list x y))

; ; (defun fb (x &optional a b c)
; ;   (list x a b c))

; ; (defun g (x y &optional z)
; ;   (let ((xy (* x y)))
; ;     (if (null z)
; ;       xy
; ;       (+ xy z))))

; ; (defun fa (x &optional (y 10))
; ;   (+ x y))

; (defun fb (x &optional
;   (a 30) (b 20) (c 80))
;   (list x a b c))
